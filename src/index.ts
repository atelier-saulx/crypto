import crypto, {
  generateKeyPair as nodeGenerateKeyPair,
  sign as nodeSign,
  verify as nodeVerify,
  constants as cryptConstants,
  publicEncrypt,
  privateDecrypt,
  randomBytes,
  createCipheriv,
} from 'node:crypto'

export const generateKeyPair = async (): Promise<{
  publicKey: string
  privateKey: string
}> =>
  new Promise((resolve, reject) => {
    nodeGenerateKeyPair(
      'rsa',
      {
        modulusLength: 2048,
        publicKeyEncoding: {
          type: 'pkcs1',
          format: 'pem',
        },
        privateKeyEncoding: {
          type: 'pkcs1',
          format: 'pem',
        },
      },
      (err, publicKey, privateKey) => {
        if (err) {
          reject(err)
        }
        resolve({ publicKey, privateKey })
      }
    )
  })

// NOTE: If used client side, provavly should
// extract the verify function to its own
// package

/**
 * Signs the payload and returns it bundled with
 * the signature in base64 encoding.
 * Expects a RSA key as the publicKey.
 * Supports strings or objects as payload.
 * NOTE: If payload is also encrypted you
 * should not use the same key pair to encrypt
 * and sign
 */
export const sign = (payload: string | object, privateKey: string): string => {
  let type: Buffer
  let payloadBuffer: Buffer
  if (typeof payload === 'object') {
    type = Buffer.from('j')
    payloadBuffer = Buffer.from(JSON.stringify(payload))
  } else {
    type = Buffer.from('s')
    payloadBuffer = Buffer.from(payload)
  }
  const signature = nodeSign('RSA-SHA256', payloadBuffer, {
    key: privateKey,
    padding: cryptConstants.RSA_PKCS1_PSS_PADDING,
  })
  return Buffer.concat([signature, payloadBuffer, type]).toString('base64')
}

/**
 * Verifies a payload previously signed with the sign() function.
 * Will return either a string or an object if the payload signed was
 * an object.
 */
export const verify = <T extends string | object>(
  payload: string,
  publicKey: string
): T => {
  const payloadBuffer = Buffer.from(payload, 'base64')
  const type = payloadBuffer.subarray(payloadBuffer.length - 1).toString('utf8')
  const signature = payloadBuffer.subarray(0, 256)
  const data = payloadBuffer.subarray(256, payloadBuffer.length - 1)

  if (
    !nodeVerify(
      'RSA-SHA256',
      data,
      {
        key: publicKey,
        padding: cryptConstants.RSA_PKCS1_PSS_PADDING,
      },
      signature
    )
  ) {
    throw new Error('Verify failed')
  }

  if (type === 'j') {
    try {
      return JSON.parse(data.toString('utf8'))
    } catch (error) {
      throw new Error('Error decoding signed data')
    }
  }

  return data.toString('utf8') as T
}

/**
 * Encrypts a string with hybrid encryption.
 * Expects a RSA key as the publicKey
 */
export const encrypt = (payload: string, publicKey: string): string => {
  const key = randomBytes(32)
  const nonce = randomBytes(16)
  const cipher = createCipheriv('chacha20', key, nonce)
  const encryptedPayload = Buffer.concat([
    cipher.update(payload, 'utf8'),
    cipher.final(),
  ])

  // console.log({ key, nonce })

  const encryptedKey = publicEncrypt(publicKey, Buffer.concat([key, nonce]))
  return encodeEncryptedKeyAndPayload(encryptedKey, encryptedPayload)
}

/**
 * Decrypts a cipher string generated by the encrypt method.
 * Expects the matching RSA private key.
 */
export const decrypt = (payload: string, privateKey: string): string => {
  const { encryptedKey, encryptedPayload } =
    decodeEncryptedKeyAndPayload(payload)
  let keyAndNonce: Buffer
  try {
    keyAndNonce = privateDecrypt(privateKey, encryptedKey)
  } catch (error) {
    throw new Error('Decrypt failed')
  }
  const key = keyAndNonce.subarray(0, 32)
  const nonce = keyAndNonce.subarray(32)
  // console.log({ key, nonce })

  const decipher = crypto.createDecipheriv('chacha20', key, nonce)
  let decryptedData = decipher.update(encryptedPayload, null, 'utf8')
  decryptedData += decipher.final('utf8')
  return decryptedData
}

const encodeEncryptedKeyAndPayload = (
  encryptedKey: Buffer,
  encryptedPayload: Buffer
): string => {
  return Buffer.concat([encryptedKey, encryptedPayload]).toString('base64')
}

const decodeEncryptedKeyAndPayload = (payload: string) => {
  const payloadBuffer = Buffer.from(payload, 'base64')
  const encryptedKey = payloadBuffer.subarray(0, 256)
  const encryptedPayload = payloadBuffer.subarray(256)
  return { encryptedKey, encryptedPayload }
}
