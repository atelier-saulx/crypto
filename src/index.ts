import {
  generateKeyPair as nodeGenerateKeyPair,
  sign as nodeSign,
  verify as nodeVerify,
  constants as cryptConstants,
  publicEncrypt,
  privateDecrypt,
  randomBytes,
  createCipheriv,
  createDecipheriv,
} from 'node:crypto'

/** Generates a RSA private/public key pair. */
export const generateKeyPair = async (): Promise<{
  publicKey: string
  privateKey: string
}> =>
  new Promise((resolve, reject) => {
    nodeGenerateKeyPair(
      'rsa',
      {
        modulusLength: 2048,
        publicKeyEncoding: {
          type: 'pkcs1',
          format: 'pem',
        },
        privateKeyEncoding: {
          type: 'pkcs1',
          format: 'pem',
        },
      },
      (err, publicKey, privateKey) => {
        if (err) {
          reject(err)
        }
        resolve({ publicKey, privateKey })
      },
    )
  })

/** Generates a tokenKey for encryptId/decryptId */
export const generateTokenKey = () => randomBytes(32).toString('hex')

// NOTE: If used client side, provavly should
// extract the verify function to its own
// package

/**
 * Signs the payload and returns it bundled with
 * the signature in base64 encoding.
 * Expects a RSA key as the publicKey.
 * Supports strings or objects as payload.
 * NOTE: If payload is also encrypted you
 * should not use the same key pair to encrypt
 * and sign
 */
export const sign = (payload: string | object, privateKey: string): string => {
  let type: Buffer
  let payloadBuffer: Buffer
  if (typeof payload === 'object') {
    type = Buffer.from('j')
    payloadBuffer = Buffer.from(JSON.stringify(payload))
  } else {
    type = Buffer.from('s')
    payloadBuffer = Buffer.from(payload)
  }
  const signature = nodeSign('RSA-SHA256', payloadBuffer, {
    key: privateKey,
    padding: cryptConstants.RSA_PKCS1_PSS_PADDING,
  })
  return Buffer.concat([signature, payloadBuffer, type]).toString('base64')
}

/**
 * Verifies a payload previously signed with the sign() function.
 * Will return either a string or an object if the payload signed was
 * an object.
 */
export const verify = <T extends string | object>(
  payload: string,
  publicKey: string,
): T => {
  const payloadBuffer = Buffer.from(payload, 'base64')
  const type = payloadBuffer.subarray(payloadBuffer.length - 1).toString('utf8')
  const signature = payloadBuffer.subarray(0, 256)
  const data = payloadBuffer.subarray(256, payloadBuffer.length - 1)

  if (
    !nodeVerify(
      'RSA-SHA256',
      data,
      {
        key: publicKey,
        padding: cryptConstants.RSA_PKCS1_PSS_PADDING,
      },
      signature,
    )
  ) {
    throw new Error('Verify failed')
  }

  if (type === 'j') {
    try {
      return JSON.parse(data.toString('utf8'))
    } catch (error) {
      throw new Error('Error decoding signed data')
    }
  }

  return data.toString('utf8') as T
}

/**
 * Encrypts a string with hybrid encryption.
 * Expects a RSA key as the publicKey
 */
export const encrypt = (payload: string, publicKey: string): string => {
  const key = randomBytes(32)
  const nonce = randomBytes(16)
  const cipher = createCipheriv('chacha20', key, nonce)
  const encryptedPayload = Buffer.concat([
    cipher.update(payload, 'utf8'),
    cipher.final(),
  ])

  // console.log({ key, nonce })

  const encryptedKey = publicEncrypt(publicKey, Buffer.concat([key, nonce]))
  return encodeEncryptedKeyAndPayload(encryptedKey, encryptedPayload)
}

/**
 * Decrypts a cipher string generated by the encrypt method.
 * Expects the matching RSA private key.
 */
export const decrypt = (payload: string, privateKey: string): string => {
  const { encryptedKey, encryptedPayload } =
    decodeEncryptedKeyAndPayload(payload)
  let keyAndNonce: Buffer
  try {
    keyAndNonce = privateDecrypt(privateKey, encryptedKey)
  } catch (error) {
    throw new Error('Decrypt failed')
  }
  const key = keyAndNonce.subarray(0, 32)
  const nonce = keyAndNonce.subarray(32)
  // console.log({ key, nonce })

  const decipher = createDecipheriv('chacha20', key, nonce)
  let decryptedData = decipher.update(encryptedPayload, null, 'utf8')
  decryptedData += decipher.final('utf8')
  return decryptedData
}

const encodeEncryptedKeyAndPayload = (
  encryptedKey: Buffer,
  encryptedPayload: Buffer,
): string => {
  return Buffer.concat([encryptedKey, encryptedPayload]).toString('base64')
}

const decodeEncryptedKeyAndPayload = (payload: string) => {
  const payloadBuffer = Buffer.from(payload, 'base64')
  const encryptedKey = payloadBuffer.subarray(0, 256)
  const encryptedPayload = payloadBuffer.subarray(256)
  return { encryptedKey, encryptedPayload }
}

const ENCRYPT_ID_IV_LENGTH = 12
const ECNRYPT_ID_AUTH_TAG_LENGTH = 16
const ECNRYPT_ID_ALGORITHM = 'aes-256-gcm'
/**
 * Encrypts id with a tokenKey.
 * expireTimestamp must be a timestamp or 0/null/undefined for no expire.
 * WARNING: Encrypted token is never repeated even with the same arguments.
 */
export const encryptId = (
  tokenKey: string,
  id: number,
  expireTimestamp: number = 0,
) => {
  if (typeof tokenKey !== 'string') {
    throw new Error('tokenKey must be a string.')
  }
  if (tokenKey.length !== 64) {
    throw new Error(
      'Invalid tokenKey size. Use this module generateTokenKey() to create a key.',
    )
  }
  if (!Number.isInteger(id) || id < 0 || id > 4294967295) {
    // 2^32 - 1
    throw new Error(
      'id must be an integer and fit within a 4-byte unsigned integer range (0 to 4294967295).',
    )
  }
  if (!Number.isInteger(expireTimestamp)) {
    throw new Error('exp must be an integer or BigInt.')
  }
  if (expireTimestamp < 0 || expireTimestamp > Number.MAX_SAFE_INTEGER) {
    console.warn(
      'exp is negative or may exceed safe integer range. Consider using BigInt for full 8-byte unsigned timestamps.',
    )
    if (expireTimestamp < 0) {
      throw new Error(
        'Timestamp must be non-negative for unsigned representation.',
      )
    }
  }

  const key = Buffer.from(tokenKey, 'hex')

  const buffer = Buffer.alloc(12)
  buffer.writeUint32LE(id, 0)

  const high = Math.floor(expireTimestamp / 2 ** 32)
  const low = expireTimestamp % 2 ** 32
  buffer.writeUInt32LE(high, 4) // Write the high 32 bits (Little-Endian, Unsigned)
  buffer.writeUInt32LE(low, 8) // Write the low 32 bits (Little-Endian, Unsigned)

  const iv = randomBytes(ENCRYPT_ID_IV_LENGTH)
  const cipher = createCipheriv(ECNRYPT_ID_ALGORITHM, key, iv, {
    authTagLength: ECNRYPT_ID_AUTH_TAG_LENGTH,
  })

  const encrypted = Buffer.concat([cipher.update(buffer), cipher.final()])

  const authTag = cipher.getAuthTag()
  const tokenBuffer = Buffer.concat([iv, encrypted, authTag])

  return tokenBuffer.toString('base64url')
}

export const decryptId = (tokenKey: string, token: string) => {
  const key = Buffer.from(tokenKey, 'hex')
  const tokenBuffer = Buffer.from(token, 'base64url')
  const iv = tokenBuffer.subarray(0, ENCRYPT_ID_IV_LENGTH)

  if (tokenBuffer.length < ENCRYPT_ID_IV_LENGTH + ENCRYPT_ID_IV_LENGTH + 12) {
    throw new Error('Token is too short.')
  }

  const encryptedPayload = tokenBuffer.subarray(
    ENCRYPT_ID_IV_LENGTH,
    tokenBuffer.length - ECNRYPT_ID_AUTH_TAG_LENGTH,
  )
  const authTag = tokenBuffer.subarray(
    tokenBuffer.length - ECNRYPT_ID_AUTH_TAG_LENGTH,
  )
  const decipher = createDecipheriv(ECNRYPT_ID_ALGORITHM, key, iv, {
    authTagLength: ECNRYPT_ID_AUTH_TAG_LENGTH,
  })
  decipher.setAuthTag(authTag)
  const decryptedPayload = Buffer.concat([
    decipher.update(encryptedPayload),
    decipher.final(),
  ])

  const id = decryptedPayload.readUInt32LE(0)

  const high = decryptedPayload.readUInt32LE(4)
  const low = decryptedPayload.readUInt32LE(8)
  const exp = high * 2 ** 32 + low

  if (exp !== 0 && exp < Date.now()) {
    throw new Error('Expired token.')
  }

  return { id, exp }
}
